<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
	"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>

<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>asm.js</title>
<link rel="stylesheet" type="text/css" href="whatwg.css">
<link rel="stylesheet" type="text/css" href="github.css">
<script src="highlight.pack.js"></script>
<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
<script>
$(document).ready(function() {
    $("div.example pre").each(function(i, e) {
        e.className = "language-javascript";
        hljs.highlightBlock(e);
    });
});
</script>
<style>
span.seq {
  border-top: solid 1px black;
}
span.meta {
  color: darkgray;
  font-size: 120%;
  margin: 0 0.2ex;
}
span.opt {
  position: relative;
  top: 0.5em;
  font-size: 80%;
  margin-left: -0.1em;
}
</style>

<body class="draft">

<div class="head">
	<h1>[TITLE]</h1>
	
	<h2 class="no-num no-toc">Working Draft â€” [DATE]</h2>
	
	<dl>
		<dt>Latest version:
		<dd><!--begin-link-->http://asmjs.org/spec/latest/<!--end-link-->
		
		<dt>Editors:
		<dd class="vcard">
			<span class="fn">David Herman</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;dherman@mozilla.com&gt;</span>
		<dd class="vcard">
			<span class="fn">Luke Wagner</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;luke@mozilla.com&gt;</span>
		<dd class="vcard">
			<span class="fn">Alon Zakai</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;azakai@mozilla.com&gt;</span>
	</dl>
</div>

<h2 class="no-num no-toc">Abstract</h2>

<p>This specification defines <strong>asm.js</strong>, a strict subset
of JavaScript that can be used as a low-level, efficient target
language for compilers. This sublanguage effectively describes a sandboxed
virtual machine for memory-unsafe languages like C or C++. A
combination of static and dynamic validation allows JavaScript engines
to employ an ahead-of-time (AOT) optimizing compilation strategy for
valid asm.js code.

<h2 class="no-num no-toc">Status</h2>

<p>This specification is working towards a candidate draft for asm.js
version 1. Mozilla's SpiderMonkey JavaScript engine provides an
optimizing implementation of this draft.

<h3 class="no-num no-toc">Changelog</h2>

<ul>
<li><strong>18 August 2014</strong>
  <ul>
    <li>better "putting it all together" example
  </ul>
<li><strong>23 July 2014</strong>
  <ul>
    <li>formatting cleanups
    <li>added variadic function types to the Global Types section
  </ul>
<li><strong>22 July 2014</strong>
  <ul>
    <li>clarified formal structure with explicit validation rule names
    <li>moved function table validation from annotations section to validation section
    <li>separated <code>case</code> and <code>default</code> validation rules
    <li>eliminated unused expected case type parameter
    <li>corrected type checks to subtype checks in <em>AdditiveExpression</em>, <em>BitwiseXORExpression</em>, <em>BitwiseANDExpression</em>, <em>BitwiseORExpression</em>, and <em>ConditionalExpression</em>
  </ul>
<li><strong>8 July 2014</strong>
  <ul>
    <li>minor editorial bugfixes
    <li>non-function foreign imports are <code>mut</code>
    <li>tightened the language on linking restrictions
  </ul>
<li><strong>7 July 2014</strong>
  <ul>
    <li>added 32-bit floating point types
    <li>renamed <code>doublish</code> to <code>double?</code> for symmetry with <code>float?</code>
    <li>separated heap access checking into a separate validation section
    <li>separated load and store types for heap views
    <li>added <code>Math.fround</code> and singleton <code>fround</code> type
    <li>added a Float Coercions section
    <li>added uncoerced <em>CallExpression</em> nodes to <em>Expression</em> for float coercions
    <li>added float coercions to initializers, return type annotations, and legal function calls
    <li>added restriction preventing float coercions of FFI calls
    <li>added <code>float</code> support for operators and <code>Math</code> functions
    <li>added <code>float</code> to legal result types for <em>ConditionalExpression</em>
    <li>added variadic <code>Math.min</code> and <code>Math.max</code>
    <li>eliminated the allowance for 1-byte views to elide their index shift (to future-proof for large heaps)
    <li>simplified and generalized link-time restrictions on heap size
  </ul>
<li><strong>12 December 2013</strong>
  <ul>
    <li>return type of <code>Math.abs</code> is <code>signed</code>
  </ul>
<li><strong>11 October 2013</strong>
  <ul>
    <li><code>unsigned</code> is not an <code>extern</code> type
    <li>added missing <code>!</code> operator to <em>UnaryExpression</em> operators
    <li>added note about <code>~~</code> to <em>Unary Operators</em> section
    <li>added note about parenthesis agnosticism to <em>Syntax</em> section
    <li>added note about ASI to <em>Syntax</em> section
    <li>added <code>-<em>NumericLiteral</em></code> cases everywhere
    <li>function calls require explicit coercions
    <li>eliminated type <code>unknown</code>, which is no longer needed
    <li>return type of integer <code>%</code> is <code>intish</code>
  </ul>
</ul>

<h2 class="no-num no-toc">Table of Contents</h2>

<!--toc-->

<h2>Introduction</h2>

<p>This specification defines <dfn>asm.js</dfn>, a strict subset of
JavaScript that can be used as a low-level, efficient target language
for compilers. The asm.js language provides an abstraction similar to
the C/C++ virtual machine: a large binary heap with efficient loads
and stores, integer and floating-point arithmetic, first-order
function definitions, and function pointers.

<h3 class="no-toc no-num">Programming Model</h3>

<p>The asm.js programming model is built around integer and
floating-point arithmetic and a virtual heap represented as
a <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays">typed
array</a>. While JavaScript does not directly provide constructs for
dealing with integers, they can be emulated using two tricks:

<ul>
<li>integer loads and stores can be performed using the typed arrays
API; and
<li>integer arithmetic is equivalent to the composition of
JavaScript's floating-point arithmetic operators with the integer
coercions performed by the bitwise operators.
</ul>

<p>As an example of the former, if we have
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/Int32Array">Int32Array</a>
view of the heap called <code>HEAP32</code>, then we can load the
32-bit integer at byte offset <code>p</code>:

<!--
<p>As an example of a load from the heap, if we have a 2MB heap
(i.e., <code>0x200000</code> bytes) and
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/Int32Array">Int32Array</a>
view of the heap called <code>HEAP32</code>, then we can load the
32-bit integer at byte offset <code>p</code>:
-->

<div class="example">
<pre>HEAP32[p >> 2]|0</pre>
</div>

<p>The shift converts the byte offset to a 32-bit element offset, and
the bitwise coercion ensures that an out-of-bounds access is coerced
from <code>undefined</code> back to an integer.

<!--
<p>The mask is required by asm.js in order to efficiently enforce that
the pointer is within the heap array's bounds, and the shift converts
the byte offset to a 32-bit element offset.
-->

<p>As an example of integer arithmetic, addition can be performed by
taking two integer values, adding them with the built-in addition
operator, and coercing the result back to an integer via the bitwise
or operator:

<div class="example">
<pre>(x+y)|0</pre>
</div>

<p>This programming model is directly inspired by the techniques
pioneered by the <a href="http://emscripten.org">Emscripten</a>
and <a href="http://mandreel.com">Mandreel</a> compilers.

<h3 class="no-num no-toc">Validation</h3>

<p>The asm.js sub-language is defined by a
<a href="#validation-rules">static type system</a> that can be checked
at JavaScript parse time. Validation of asm.js code is designed to be
"pay-as-you-go" in that it is never performed on code that does not
request it. An asm.js <dfn>module</dfn> requests validation by means
of a
special <a href="http://ecma-international.org/ecma-262/5.1/#sec-14.1">prologue
directive</a>, similar to that of ECMAScript Edition
5's <a href="http://ecma-international.org/ecma-262/5.1/#sec-10.1.1">strict
mode</a>:

<div class="example">
<pre>function MyAsmModule() {
    "use asm";
    // module body
}</pre>
</div>

<p>This explicit directive allows JavaScript engines to avoid
performing pointless and potentially costly validation on other
JavaScript code, and to report validation errors in developer consoles
only where relevant.

<h3 class="no-num no-toc">Ahead-Of-Time Compilation</h3>

<p>Because asm.js is a strict subset of JavaScript, this specification
only defines the validation logic&mdash;the execution semantics is
simply that of JavaScript. However, validated asm.js is amenable to
ahead-of-time (AOT) compilation. Moreover, the code generated by an
AOT compiler can be quite efficient, featuring:

<ul>
<li>unboxed representations of integers and floating-point numbers;
<li>absence of runtime type checks;
<li>absence of garbage collection; and
<li>efficient heap loads and stores (with implementation strategies varying by platform).
</ul>

<p>Code that fails to validate must fall back to execution by
traditional means, e.g., interpretation and/or just-in-time (JIT)
compilation.

<!--
Moreover, the low-level nature of validated asm.js code makes it
possible for AOT implementations to perform aggressive optimizations
without profiling, heuristics, or dynamic deoptimization or
recompilation.
-->

<h3 class="no-num no-toc">Linking</h3>

<p>Using an asm.js module requires calling its function to obtain an
object containing the module's exports; this is known
as <dfn>linking</dfn>. An asm.js module can also be given access to
standard libraries and custom JavaScript functions through linking. An
AOT implementation must perform certain <a href="#linking-0">dynamic
checks</a> to check compile-time assumptions about the linked
libraries in order to make use of the compiled code.

<p>This figure depicts a simple architecture of an AOT implementation
that otherwise employs a simple interpreter. If either dynamic or
static validation fails, the implementation must fall back to the
interpreter. But if both validations succeed, calling the module
exports executes the binary executable code generated by AOT
compilation.

<figure class="diagrams">
<a href="aot.png"><img src="aot.png" width="800" height="200"></a>
</figure>

<h3 class="no-num no-toc">External Code and Data</h3>

<p>Within an asm.js module, all code is fully statically typed and
limited to the very restrictive asm.js dialect. However, it is
possible to interact with recognized standard JavaScript libraries and
even custom dynamic JavaScript functions.

<p>An asm.js module can take up to three optional parameters,
providing access to external JavaScript code and data:

<ul>
<li>a <dfn>standard library</dfn> object, providing access to a
limited subset of the JavaScript <a href="#standard-library">standard
libraries</a>;
<li>a <dfn>foreign function interface</dfn> (FFI), providing access to
custom external JavaScript functions; and
<li>a <dfn>heap buffer</dfn>, providing a
single <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a>
to act as the asm.js heap.
</ul>

<p>These objects allow asm.js to call into external JavaScript (and to
share its heap buffer with external JavaScript). Conversely, the
exports object returned from the module allows external JavaScript to
call into asm.js.

<p>So in the general case, an asm.js module declaration looks like:

<div class="example">
<pre>function MyAsmModule(stdlib, foreign, heap) {
    "use asm";

    // module body...

    return {
        export1: f1,
        export2: f2,
        // ...
    };
}
</div>

<p>Function parameters in asm.js are provided a type annotation by
means of an explicit coercion on function entry:

<div class="example">
<pre>function geometricMean(start, end) {
  start = start|0; // start has type int
  end = end|0;     // end has type int
  return +exp(+logSum(start, end) / +((end - start)|0));
}</pre>
<!--
<pre>function diag(x, y) {
    x = +x; // x has type double
    y = +y; // y has type double
    return +sqrt(+square(x) + +square(y));
}</pre>
-->
</div>

<p>These annotations serve two purposes: first, to provide the
function's type signature so that the validator can enforce that all
calls to the function are well-typed; second, to ensure that even if
the function is exported and called by external JavaScript, its
arguments are dynamically coerced to the expected type. This ensures
that an AOT implementation can use unboxed value representations,
knowing that once the dynamic coercions have completed, the function
body never needs any runtime type checks.

<h3 class="no-num no-toc">Putting It All Together</h3>

<p>The following is a small but complete example of an asm.js module.

<div class="example">
<pre>function GeometricMean(stdlib, foreign, buffer) {
  "use asm";

  var exp = stdlib.Math.exp;
  var log = stdlib.Math.log;
  var values = new stdlib.Float64Array(buffer);

  function logSum(start, end) {
    start = start|0;
    end = end|0;

    var sum = 0.0, p = 0, q = 0;

    // asm.js forces byte addressing of the heap by requiring shifting by 3
    for (p = start << 3, q = end << 3; (p|0) < (q|0); p = (p + 8)|0) {
      sum = sum + +log(values[p>>3]);
    }

    return +sum;
  }

  function geometricMean(start, end) {
    start = start|0;
    end = end|0;

    return +exp(+logSum(start, end) / +((end - start)|0));
  }

  return { geometricMean: geometricMean };
}</pre>
</div>

<p>In a JavaScript engine that supports AOT compilation of asm.js,
calling the module on a proper global object and heap buffer would
link the exports object to use the statically compiled functions.

<div class="example">
<pre>var heap = new ArrayBuffer(0x10000);          // 64k heap
init(heap, START, END);                       // fill a region with input values
var fast = GeometricMean(window, null, heap); // produce exports object linked to AOT-compiled code
fast.geometricMean(START, END);               // computes geometric mean of input values</pre>
</div>

<p>By contrast, calling the module on a standard library object
containing something other than the true <code>Math.exp</code> or
<code>Math.log</code> would fail to produce AOT-compiled code:

<div class="example">
<pre>var bogusGlobal = {
  Math: {
    exp: function(x) { return x; },
    log: function(x) { return x; }
  },
  Float64Array: Float64Array
};

var slow = GeometricMean(bogusGlobal, null, heap); // produces purely-interpreted/JITted version
console.log(slow.geometricMean(START, END));       // computes bizarro-geometric mean thanks to bogusGlobal</pre>
</div>

<!--
<p>In a JavaScript engine that supports AOT compilation of asm.js,
calling the module on a true global object would produce a fully
compiled exports object:

<div class="example">
<pre>var fast = DiagModule(window);     // produces AOT-compiled version
console.log(fast.diag(3, 4));      // 5</pre>
</div>

<p>By contrast, calling the module on a standard library object
containing something other than the true <code>Math.sqrt</code> would
fail to produce compiled code:

<div class="example">
<pre>var bogusGlobal = {
    Math: {
        sqrt: function(x) { return x * 2; }
    }
};

var slow = DiagModule(bogusGlobal); // produces purely-interpreted version
console.log(slow.diag(3, 4));       // 50</pre>
</div>
-->

<h2>Types</h2>

<p>Validation of an asm.js module relies on a static type system that
classifies and constrains the syntax. This section defines the types
used by the validation logic.

<h3>Value Types</h3>

<p>Validation in asm.js limits JavaScript programs to only use operations
that can be mapped closely to efficient data representations and
machine operations of modern architectures, such as 32-bit integers
and integer arithmetic.

<p>The types of asm.js values are inter-related by a subtyping
relation, which can be represented pictorially:

<figure class="diagrams">
<a href="subtypes.png"><img src="subtypes.png" width="779" height="348"></a>
</figure>

<p>The light boxes represent arbitrary JavaScript values that may flow
freely between asm.js code and external JavaScript code.

<p>The dark boxes represent types that are disallowed from escaping
into external (i.e., non-asm.js) JavaScript code. (These values can be
given efficient, unboxed representations in optimized asm.js
implementations that would be unsound if they were allowed to escape.)

<p>The meta-variables &sigma; and &tau; are used to stand for value
types.

<h4>void</h4>

<p>The <dfn><code>void</code></dfn> type is the type of functions that
are not supposed to return any useful value. As JavaScript functions,
they produce the <code>undefined</code> value, but asm.js code is not
allowed to make use of this value; functions with return
type <code>void</code> can only be called for effect.

<h4>double</h4>

<p>The <dfn><code>double</code></dfn> type is the type of ordinary
JavaScript double-precision floating-point numbers.

<h4>signed</h4>

<p>The <dfn><code>signed</code></dfn> type is the type of signed
32-bit integers. While there is no direct concept of integers in
JavaScript, 32-bit integers can be represented as doubles, and integer
operations can be performed with JavaScript arithmetic, relational,
and bitwise operators.

<h4>unsigned</h4>

<p>The <dfn><code>unsigned</code></dfn> type is the type of unsigned
32-bit integers. Again, these are not a first-class concept in
JavaScript, but can be represented as floating-point numbers.

<h4>int</h4>

<p>The <dfn><code>int</code></dfn> type is the type of 32-bit integers
where the signedness is not known. In asm.js, the type of a variable
never has a known signedness. This allows them to be compiled as
32-bit integer registers and memory words. However, this
representation creates an overlap between signed and unsigned numbers
that causes an ambiguity in determining which JavaScript number they
represent. For example, the bit pattern <code>0xffffffff</code> could
represent 4294967295 or -1, depending on the signedness. For this
reason, values of the <code>int</code> type are disallowed from
escaping into external (non-asm.js) JavaScript code.

<h4>fixnum</h4>

<p>The <dfn><code>fixnum</code></dfn> type is the type of integers in the
range [0, 2<sup>31</sup>)&mdash;that is, the range of integers such
that an unboxed 32-bit representation has the same value whether it is
interpreted as signed or unsigned.


<h4>intish</h4>

<p>Even though JavaScript only supports floating-point arithmetic,
most operations can simulate integer arithmetic by coercing their
result to an integer. For example, adding two integers may overflow
beyond the 32-bit range, but coercing the result back to an integer
produces the same 32-bit integer as integer addition in, say, C.

<p>The <dfn><code>intish</code></dfn> type represents the result of a
JavaScript integer operation that must be coerced back to an integer
with an explicit coercion
(<a href="http://ecma-international.org/ecma-262/5.1/#sec-9.5"><em>ToInt32</em></a>
for signed integers
and <a href="http://ecma-international.org/ecma-262/5.1/#sec-9.6"><em>ToUint32</em></a>
for unsigned integers). Validation requires all <code>intish</code>
values to be immediately passed to an operator or standard library
that performs the appropriate coercion or else dropped via an
expression statement. This way, each integer operation can be
compiled directly to machine operations.

<p>The one operator that does not support this approach is
multiplication. (Multiplying two large integers can result in a large
enough double that some lower bits of precision are lost.) So asm.js
does not support applying the multiplication operator to integer
operands. Instead, the
proposed <a href="https://mail.mozilla.org/pipermail/es-discuss/2012-November/026126.html"><code>Math.imul</code></a>
function is recommended as the proper means of implementing integer
multiplication.


<h4>double?</h4>

<p>The <dfn><code>double?</code></dfn> type represents operations that
are expected to produce a <code>double</code> but may also produce
<code>undefined</code>, and so must be coerced back to a number
via <a href="http://ecma-international.org/ecma-262/5.1/#sec-9.3"><em>ToNumber</em></a>.
Specifically, reading out of bounds from a typed array
produces <code>undefined</code>.

<h4>float</h4>

<p>The <dfn><code>float</code></dfn> type is the type of 32-bit
floating-point numbers.

<h4>float?</h4>

<p>The <dfn><code>float?</code></dfn> type represents operations that
are expected to produce a <code>float</code> but, similar
to <code>double?</code>, may also produce <code>undefined</code> and
so must be coerced back to a 32-bit floating point number
via <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-math.fround"><em>fround</em></a>.
Specifically, reading out of bounds from a typed array
produces <code>undefined</code>.

<h4>floatish</h4>

<p>Similar to integers, JavaScript can almost support 32-bit
floating-point arithmetic, but requires extra coercions to properly
emulate the 32-bit semantics. As proved in
<em><a href="http://dl.acm.org/citation.cfm?id=221334">When is double
rounding innocuous?</a></em> (Figueroa 1995), both the 32- and 64-bit
versions of standard arithmetic operations produce equivalent results
when given 32-bit inputs and coerced to 32-bit outputs.

<p>The <dfn><code>floatish</code></dfn> type,
like <code>intish</code>, represents the result of a JavaScript 32-bit
floating-point operations that must be coerced back to a 32-bit
floating-point value with an
explicit <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-math.fround"><em>fround</em></a>
coercion. Validation requires all <code>floatish</code> values to be
immediately passed to an operator or standard library that performs
the appropriate coercion or else dropped via an expression
statement. This way, each 32-bit floating-point operation can be
<a href="https://blog.mozilla.org/javascript/2013/11/07/efficient-float32-arithmetic-in-javascript/">compiled
directly to machine operations</a>.

<h4>extern</h4>

The abstract <dfn><code>extern</code></dfn> type represents the root
of all types that can escape back into external JavaScript&mdash;in
other words, the light boxes in the above diagram.

<h3>Global Types</h3>

<p>Variables and functions defined at the top-level scope of an asm.js
module can have additional types beyond
the <a href="#value-types">value types</a>. These include:

<ul>
<li>value types &tau;;
<li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a> types <code>Int<em>n</em>Array</code>, <code>Uint<em>n</em>Array</code>, and <code>Float<em>n</em>Array</code>;
<li>function types ((&sigma;, &hellip;) &rarr; &tau;) &and; &hellip; &and; ((&sigma;&prime;, &hellip;) &rarr; &tau;&prime;);
<li>variadic function types ((&sigma;, &sigma;<code>&hellip;</code>) &rarr; &tau;) &and; &hellip; &and; ((&sigma;&prime;, &sigma;&prime;<code>&hellip;</code>) &rarr; &tau;&prime;);
<li>function table types ((&sigma;, &hellip;) &rarr; &tau;)[<em>n</em>];
<li>the special type <code>fround</code> of <code>Math.fround</code>; and
<li>the FFI function type <code>Function</code>.
</ul>

<p>The "&and;" notation for function types serves to represent
overloaded functions and operators. For example,
the <a href="#standard-library"><code>Math.abs</code> function</a> is
overloaded to accept either integers or floating-point numbers, and
returns a different type in each case. Similarly, many of
the <a href="#operators">operators</a> have overloaded types.

<p>The meta-variable &gamma; is used to stand for global types.

<h2>Environments</h2>

<p>Validating an asm.js module depends on tracking contextual
information about the set of definitions and variables in scope. This
section defines the <dfn>environments</dfn> used by the validation
logic.

<h3>Global Environment</h3>

<p>An asm.js module is validated in the context of a <dfn>global
environment</dfn>. The global environment maps each global variable to
its type as well as indicating whether the variable is mutable:

<p><div>{ <em>x</em> : <span class="meta">(</span><tt>mut<span class="meta">|</span>imm</tt><span class="meta">)</span> &gamma;, &hellip; }</div>

<p>The meta-variable &Delta; is used to stand for a global environment.

<h3>Variable Environment</h3>

<p>In addition to the <span>global environment</span>, each function
body in an asm.js module is validated in the context of
a <dfn>variable environment</dfn>. The variable environment maps each
function parameter and local variable to its value type:

<p>{ <em>x</em> : &tau;, &hellip; }

<p>The meta-variable &Gamma; is used to stand for a variable environment.

<h3>Environment Lookup</h3>

<p>Looking up a variable's type

<div class="example">
<em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>)
</div>

<p>is defined by:

<ul>
<li>&tau; if <em>x</em> : &tau; occurs in &Gamma;;
<li>&gamma; if <em>x</em> does not occur in &Gamma; and <em>x</em>
: <code>mut</code> &gamma; or <em>x</em> : <code>imm</code> &gamma;
occurs in &Delta;
</ul>

<p>If <em>x</em> does not occur in either environment then
the <em>Lookup</em> function has no result.

<h2>Syntax</h2>

<p>Validation of an asm.js module is specified by reference to
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-A">ECMAScript
grammar</a>, but conceptually operates at the level of abstract
syntax. In particular, an asm.js validator must obey the following
rules:

<ul>
<li>Empty statements (<code>;</code>) are always ignored, whether in
the top level of a module or inside an asm.js function body.
<li>No variables bound anywhere in an asm.js module (whether in the
module function parameter list, global variable declarations, asm.js
function names, asm.js function parameters, or local variable
declarations) may have the name <code>eval</code>
or <code>arguments</code>.
<li>Where it would otherwise parse equivalently in JavaScript,
parentheses are meaningless. Even where the specification matches on
specific productions of <em>Expression</em> such as literals, the
source may contain extra meaningless parentheses without affecting
validation.
<li>Automatic semicolon insertion is respected. An asm.js source file
may omit semicolons wherever JavaScript allows them to be omitted.
</ul>

<p>These rules are otherwise left implicit in the rest of the
specification.

<h2>Annotations</h2>

<p>All variables in asm.js are explicitly annotated with type
information so that their type can be statically enforced by
validation.

<h3>Parameter Type Annotations</h3>

<p>Every parameter in an asm.js function is provided with an explicit
type annotation in the form of a coercion. This coercion serves two
purposes: the first is to make the parameter type statically apparent
for validation; the second is to ensure that if the function is
exported, the arguments dynamically provided by external JavaScript
callers are coerced to the expected type. For example, a bitwise OR
coercion annotates a parameter as having type <code>int</code>:

<div class="example">
<pre>function add1(x) {
    x = x|0; // x : int
    return (x+1)|0;
}</pre>
</div>

<p>In an AOT implementation, the body of the function can be
implemented fully optimized, and the function can be given two entry
points: an internal entry point for asm.js callers, which are
statically known to provide the proper type, and an external dynamic
entry point for JavaScript callers, which must perform the full
coercions (which might involve arbitrary JavaScript computation, e.g.,
via implicit calls to <code>valueOf</code>).

<p>There are three recognized parameter type annotations:

<div class="example">
<em>x:Identifier</em> <code>=</code> <em>x:Identifier</em><code>|0;</code><br>
<em>x:Identifier</em> <code>=</code> <code>+</code><em>x:Identifier</em><code>;</code><br>
<em>x:Identifier</em> <code>=</code> <em>f:Identifier</em><code>(</code><em>x:Identifier</em><code>);</code>
</div>

<p>The first form annotates a parameter as type <code>int</code>, the
second as type <code>double</code>, and the third as
type <code>float</code>. In the latter case,
<em>Lookup</em>(&Delta;, &Gamma;, <em>f</em>) must
be <code>fround</code>.

<h3>Return Type Annotations</h3>

<p>An asm.js function's <em>formal return type</em> is determined by
the last statement in the function body, which for
non-<code>void</code> functions is required to be
a <em>ReturnStatement</em>. This distinguished return statement may
take one of five forms:

<div class="example">
<code>return +</code><em>e:Expression</em><code>;</code><br>
<code>return </code><em>e:Expression</em><code>|0;</code><br>
<code>return </code><em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>;</code><br>
<code>return </code><em>f:Identifier</em><code>(</code><em>arg:Expression</em><code>);</code><br>
<code>return;</code>
</div>

<p>The first form has return type <code>double</code>. The second has
type <code>signed</code>. The third has return
type <code>double</code> if <em>n</em> is composed of a floating-point
literal, i.e., a numeric literal with the character <code>.</code> in
its source; alternatively, if <em>n</em> is composed of an integer
literal and has its value in the range [-2<sup>31</sup>,
2<sup>31</sup>), the return statement has return
type <code>signed</code>. The fourth form has return
type <code>float</code>, and the fifth has return
type <code>void</code>.

<p>If the last statement in the function body is not
a <em>ReturnStatement</em>, or if the function body has no non-empty
statements (other than the initial declarations and
coercions&mdash;see <a href="#function-declarations">Function
Declarations</a>), the function's return type is <code>void</code>.

<h3>Function Type Annotations</h3>

<p>The type of a function declaration

<div class="example">
<code>function</code> <em>f:Identifier</em><code>(</code><em>x:Identifier</em>&hellip;<code>) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>x:Identifier</em> <code>=</code> <em>AssignmentExpression</em><code>;</code><span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><code>var </code><span class="meta">(</span><em>y:Identifier</em> <code>=</code> <span class="meta">(</span><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em> <span class="meta">|</span> <em>Identifier</em><code>(</code><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>)</code><span class="meta">)</span><span class="meta">)</span><code>,</code>&hellip;<span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>body:Statement</em>&hellip;<br>
<code>}</code>
</div>

<p>is (&sigma;,&hellip;) &rarr; &tau; where &sigma;,&hellip; are the
types of the parameters, as provided by
the <a href="#parameter-type-annotations">parameter type
annotations</a>, and &tau; is the formal return type, as provided by
the <a href="#return-type-annotations">return type annotation</a>. The
variable <em>f</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm</code> (&sigma;,&hellip;) &rarr; &tau;.

<h3>Variable Type Annotations</h3>

<p>The types of variable declarations are determined by their
initializer, which may take one of two forms:

<div class="example">
<em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><br>
<em>f:Identifier</em><code>(</code><em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>)</code>
<!--<em>x:Identifier</em>-->
</div>

<p>In the first case, the variable type is <code>double</code>
if <em>n</em>'s source contains the character <code>.</code>;
otherwise <em>n</em> may be an integer literal in the range
[-2<sup>31</sup>, 2<sup>32</sup>), in which case the variable type
is <code>int</code>.

<p>In the second case, the variable type
is <code>float</code>. <em>Lookup</em>(&Delta;, &Gamma;, <em>f</em>)
must be <code>fround</code> and <em>n</em> must be a floating-point
literal with the character <code>.</code> in its source.

<!--
<p>In the third case, the variable type is &tau;
if <em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>) is <code>imm</code>
&tau;.
-->

<h3>Global Variable Type Annotations</h3>

<p>A global variable declaration is a <em>VariableStatement</em> node
in one of several allowed forms. Validating global variable
annotations takes a &Delta; as input and produces as output a new
&Delta;&prime; by adding the variable binding to &Delta;.

<p>A global program variable is initialized to a literal:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>f:Identifier</em><code>(</code><em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>);</code>
</div>

<p>The global variable <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>mut</code> &tau;, where &tau; is determined in the same way
as local <a href="#variable-type-annotations">variable type
annotations</a>.

<p>A standard library import is of one of the following two forms:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>stdlib:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>stdlib:Identifier</em><code>.Math.</code><em>y:Identifier</em><code>;</code>
</div>

<p>The variable <em>stdlib</em> must match the first parameter of
the <a href="#modules">module declaration</a>. The global
variable <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm</code> &gamma;, where &gamma; is the type of
library <em>y</em> or <code>Math.</code><em>y</em> as specified by
the <a href="#standard-library">standard library types</a>.

<p>A foreign import is of one of the following three forms:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>|0;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <code>+</code><em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code>
</div>

<p>The variable <em>foreign</em> must match the second parameter of
the <a href="#modules">module declaration</a>. The global
variable <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm Function</code> for the first form, <code>mut
int</code> for the second, and <code>mut double</code> for the third.

<p>A global heap view is of the following form:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>= new</code> <em>stdlib:Identifier</em><code>.</code><em>view:Identifier</em><code>(</code><em>heap:Identifier</em><code>);</code>
</div>

<p>The variable <em>stdlib</em> must match the first parameter of
the <a href="#modules">module declaration</a> and the
variable <em>heap</em> must match the third. The
identifier <em>view</em> must be one of the
standard <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type names. The global variable <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm</code>
<em>view</em>.

<h3>Function Table Types</h3>

<p>A function table is a <em>VariableStatement</em> of the form:

<div class="example">
<code>var</code> <em>x<sub>0</sub>:Identifier</em><code> = [</code><em>f<sub>0</sub>:Identifier</em><code>,</code> <em>f<sub>1</sub>:Identifier</em><code>,</code>&hellip;<code>],</code> <em>x<sub>1</sub>:Identifier</em><code> = [</code><em>g<sub>0</sub>:Identifier</em><code>,</code> <em>g<sub>1</sub>:Identifier</em><code>,</code>&hellip;<code>],</code>&hellip;<code>;</code>
</div>

<p>The function table <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm</code> ((&sigma;,&hellip;) &rarr; &tau;)[<em>n</em>]
where (&sigma;,&hellip;) &rarr; &tau; is the type of <em>f</em> in the
global environment and <em>n</em> is the length of the array literal.

<!--
<p>The length of the array literal must be a power of two and all the
identifiers <em>f</em> must map to the same type <code>imm</code>
(&sigma;,&hellip;) &rarr; &tau; in
the <a href="#global-environment">global environment</a>. The function
table <em>x</em> is stored in the global environment with
type <code>imm</code> ((&sigma;,&hellip;) &rarr; &tau;)[<em>n</em>]
where <em>n</em> is the length of the array literal.
-->

<h2>Validation Rules</h2>

<p>To ensure that a JavaScript function is a proper asm.js module, it
must first be statically validated. This section specifies the
validation rules. The rules operate on JavaScript abstract syntax,
i.e., the output of a JavaScript parser. The non-terminals refer to
parse nodes defined by productions in
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-A">ECMAScript
grammar</a>, but note that the asm.js validator only accepts a subset
of legal JavaScript programs.

<p>The result of a validation operation is either
a <dfn>success</dfn>, indicating that a parse node is statically valid
asm.js, or a <dfn>failure</dfn>, indicating that the parse node is
statically invalid asm.js.

<h3><em>ValidateModule</em>(<em>f</em>)</h3>

<p>The <em>ValidateModule</em> rule validates an asm.js module, which
is either a <em>FunctionDeclaration</em>
or <em>FunctionExpression</em> node.

<p>Validating a module of the form

<div class="example">
<code>function</code> <em>f:Identifier<sub>opt</sub></em><code>(</code><span class="meta">(</span><em>stdlib:Identifier</em><code><span class="meta">(</span>,</code> <em>foreign:Identifier</em><span class="meta">(</span><code>,</code> <em>heap:Identifier</em><span class="meta">)</span><sub><em>opt</em></sub><span class="meta">)</span><sub><em>opt</em></sub><span class="meta">)</span><sub><em>opt</em></sub><code>) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;"use asm";</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>var:VariableStatement</em>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>fun:FunctionDeclaration</em>&hellip;<br>
<!--
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>var:VariableStatement</em> <span class="meta">|</span> <em>fun:FunctionDeclaration</em><span class="meta">)</span>&hellip;<br>
-->
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>table:VariableStatement</em>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>exports:ReturnStatement</em><br>
<code>}</code>
</div>

<p>succeeds if:

<ul>
<li><em>f</em>, <em>stdlib</em>, <em>foreign</em>, <em>heap</em>, and
the <em>var</em>, <em>fun</em>, and <em>table</em> variables are all
mutually distinct;
<li>the global environment &Delta; is constructed in three stages:
  <ol>
  <li>the <a href="#global-declarations">global declarations</a> are
  validated in an empty initial environment &Delta;<sub>0</sub>,
  producing a new global environment &Delta;<sub>1</sub>;
  <li>the types from the <a href="#function-type-annotations">function
  type annotations</a> in the <em>fun</em> declarations are extracted
  using &Delta;<sub>1</sub>, and then added to &Delta;<sub>1</sub> to
  produce &Delta;<sub>2</sub>;
<!--
  <li>the types from
  the <a href="#global-variable-type-annotations">global variable type
  annotations</a> in the <em>var</em> declarations and
  the <a href="#function-type-annotations">function type
  annotations</a> in the <em>fun</em> declarations are the initial
  contents of &Delta;;
-->
  <li>the types of the <a href="#function-table-types">function
  tables</a> in the <em>table</em> declarations</a> are extracted
  using &Delta;<sub>2</sub>, and their types are added to
  &Delta;<sub>2</sub> to produce the completed global type environment
  &Delta;.
  </ol>
<li>for each <em>fun</em> declaration, <a href="#validatefunction-f"><em>ValidateFunction</em></a> succeeds with environment &Delta;;
<li>for each <em>table</em> declaration, <a href="#validatefunctiontable-s"><em>ValidateFunctionTable</em></a> succeeds with environment &Delta;; and
<li><a href="#validateexport-s"><em>ValidateExport</em></a> succeeds for <em>exports</em> with environment &Delta;.
</ul>


<h3><em>ValidateExport</em>(&Delta;, <em>s</em>)</h3>

<p>The <em>ValidateExport</em> rule validates an asm.js module's
export declaration. An export declaration is
a <em>ReturnStatement</em> returning either a single asm.js function
or an object literal exporting multiple asm.js functions.

<p>Validating an export declaration node

<div class="example">
<code>return</code> <code>{</code> <span class="meta">(</span><em>x:Identifier</em> <code>:</code> <em>f:Identifier</em><span class="meta">)</span><code>,</code>&hellip; <code> };</code>
</div>

<p>succeeds if for each <em>f</em>, &Delta;(f) = <code>imm</code>
&gamma; where &gamma; is a function type (&sigma;,&hellip;) &rarr;
&tau;.

<p>Validating an export declaration node

<div class="example">
<code>return</code> <em>f:Identifier</em><code>;</code>
</div>

<p>succeeds if &Delta;(<em>f</em>) = <code>imm</code> &gamma; where
&gamma; is a function type (&sigma;,&hellip;) &rarr; &tau;.

<h3><em>ValidateFunctionTable</em>(&Delta;, <em>s</em>)</h3>

<p>The <em>ValidateFunctionTable</em> rule validates an asm.js
module's function table declaration. A function table declaration is
a <em>VariableStatement</em> binding an identifier to an array
literal.

<p>Validating a function table of the form

<div class="example">
<code>var</code> <em>x:Identifier</em><code> = [</code><em>f:Identifier</em><code>,</code>&hellip;<code>];</code>
</div>

<p>succeeds if:

<ul>
<li>the length <em>n</em> of the array literal is 2<sup><em>m</em></sup> for some <em>m</em> &geq; 0;
<li>&Delta;(<em>x</em>) = <code>imm</code> ((&sigma;,&hellip;) &rarr; &tau;)[<em>n</em>]; and
<li>for each <em>f</em>, &Delta;(<em>f</em>) = (&sigma;,&hellip;) &rarr; &tau;.
</ul>


<h3><em>ValidateFunction</em>(&Delta;, <em>f</em>)</h3>

<p>The <em>ValidateFunction</em> rule validates an asm.js function
declaration, which is a <em>FunctionDeclaration</em> node.

<p>Validating a function declaration of the form

<div class="example">
<code>function</code> <em>f:Identifier</em><code>(</code><em>x:Identifier</em><code>,</code>&hellip;<code>) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>x:Identifier</em> <code>=</code> <em>AssignmentExpression</em><code>;</code><span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><code>var </code><span class="meta">(</span><em>y:Identifier</em> <code>=</code> <span class="meta">(</span><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em> <span class="meta">|</span> <em>Identifier</em><code>(</code><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>)</code><span class="meta">)</span><span class="meta">)</span><code>,</code>&hellip;<span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>body:Statement</em>&hellip;<br>
<code>}</code>
</div>

<p>succeeds if:

<ul>
<li>&Delta;(f) = <code>imm</code> (&sigma;,&hellip;) &rarr; &tau;;
<li>the <em>x</em> and <em>y</em> variables are all mutually distinct;
<li>the variable environment &Gamma; is constructed by mapping each
parameter <em>x</em> to its
corresponding <a href="#parameter-type-annotations">parameter type
annotation</a> (annotations must appear in the same order as the
parameters) and each local variable <em>y</em> to
its <a href="#variable-type-annotations">variable type annotation</a>;
<li>for each <em>body</em>
statement, <a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds with environments &Delta; and &Gamma; and expected return
type &tau;.
</ul>

<h3><em>ValidateStatement</em>(&Delta;, &Gamma;, &tau;, <em>s</em>)</h3>

<p>The <em>ValidateStatement</em> rule validates an asm.js statement.
Each statement is validated in the context of a <span>global
environment</span> &Delta;, a <span>variable environment</span>
&Gamma;, and an expected return type &tau;. Unless otherwise
explicitly stated, a recursive validation of a subterm uses the same
context as its containing term.

<h4>Block</h4>

<p>Validating a <em>Block</em> statement node

<div class="example">
<code>{</code> <em>stmt:Statement</em>&hellip; <code>}</code>
</div>

<p>succeeds
if <a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds for each <em>stmt</em>.

<h4>ExpressionStatement</h4>

<p>Validating an <em>ExpressionStatement</em> node

<div class="example">
<em>cexpr:CallExpression</em> <code>;</code>
</div>

<p>succeeds if <a href="#validatecall-e"><em>ValidateCall</em></a>
succeeds for <em>cexpr</em> with actual return type <code>void</code>.

<p>Validating an <em>ExpressionStatement</em> node

<div class="example">
<em>expr:Expression</em> <code>;</code>
</div>

<p>succeeds
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr</em> with some type &sigma;.

<h4>EmptyStatement</h3>

<p>Validating an <em>EmptyStatement</em> node always succeeds.

<h4>IfStatement</h4>

<p>Validating an <em>IfStatement</em> node

<div class="example">
<code>if (</code> <em>expr:Expression</em> <code>)</code> <em>stmt<sub>1</sub>:Statement</em> <code>else</code> <em>stmt<sub>2</sub>:Statement</em>
</div>

<p>succeeds
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr</em> with a subtype of <code>int</code>
and <a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds for <em>stmt<sub>1</sub></em> and <em>stmt<sub>2</sub></em>.

<p>Validating an <em>IfStatement</em> node

<div class="example">
<code>if (</code> <em>expr:Expression</em> <code>)</code> <em>stmt:Statement</em>
</div>

<p>succeeds
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr</em> with a subtype of <code>int</code>
and <a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds for <em>stmt</em>.

<h4>ReturnStatement</h4>

<p>Validating a <em>ReturnStatement</em> node

<div class="example">
<code>return</code> <em>expr:Expression</em> <code>;</code>
</div>

<p>succeeds
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr</em> with a subtype of the expected return type
&tau;.

<p>Validating a <em>ReturnStatement</em> node

<div class="example">
<code>return ;</code>
</div>

<p>succeeds if the expected return type &tau; is <code>void</code>.


<h4>IterationStatement</h4>

<p>Validating an <em>IterationStatement</em> node

<div class="example">
<code>while (</code> <em>expr:Expression</em> <code>)</code> <em>stmt:Statement</em>
</div>

<p>succeeds
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr</em> with a subtype of <code>int</code>
and <a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds for <em>stmt</em>.

<p>Validating an <em>IterationStatement</em> node

<div class="example">
<code>do</code> <em>stmt:Statement</em> <code>while (</code> <em>expr:Expression</em> <code>) ;</code>
</div>

<p>succeeds
if <a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds for <em>stmt</em>
and <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr</em> with a subtype of <code>int</code>.

<p>Validate an <em>IterationStatement</em> node

<div class="example">
<code>for (</code> <em>init:ExpressionNoIn<sub>opt</sub></em> <code>;</code> <em>test:Expression<sub>opt</sub></em> <code>;</code> <em>update:Expression<sub>opt</sub></em> <code>)</code> <em>body:Statement</em>
</div>

<p>succeeds if:

<ul>
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a> succeeds for <em>init</em> (if present);
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>test</em> with a subtype of <code>int</code> (if
present);
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>update</em> (if present); and
<li><a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds for <em>body</em>.
</ul>

<h4>BreakStatement</h4>

<p>Validating a <em>BreakStatement</em> node

<div class="example">
<code>break</code> <em>Identifier<sub>opt</sub></em> <code>;</code>
</div>

<p>always succeeds.

<h4>ContinueStatement</h4>

<p>Validating a <em>ContinueStatement</em> node

<div class="example">
<code>continue</code> <em>Identifier<sub>opt</sub></em> <code>;</code>
</div>

<p>always succeeds.

<h4>LabelledStatement</h4>

<p>Validating a <em>LabelledStatement</em> node

<div class="example">
<em>Identifier</em> <code>:</code> <em>body:Statement</em>
</div>

<p>succeeds
if <a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds for <em>body</em>.

<h4>SwitchStatement</h4>

<p>Validating a <em>SwitchStatement</em> node

<div class="example">
<code>switch (</code> <em>test:Expression</em> <code>)</code> <code>{</code> <em>case:CaseClause</em>&hellip; <em>default:DefaultClause<sub>opt</sub></em> <code>}</code>
</div>

<p>succeeds if

<ul>
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a> succeeds for <em>test</em> with a subtype of <code>signed</code>;
<li><a href="#validatecase-c"><em>ValidateCase</em></a> succeeds for each <em>case</em>;
<li>each <em>case</em> value is distinct;
<li>the difference between the maximum and minimum <em>case</em> values is less than 2<sup>31</sup>; and
<li><a href="#validatedefault-d"><em>ValidateDefault</em></a> succeeds for <em>default</em>.
</ul>

<!--
<div class="compilation">
<p>
A <code>switch</code> statement in asm.js is intended to be compiled
unconditionally (i.e., regardless of its contents) to
a <a href="http://en.wikipedia.org/wiki/Branch_table">jump
table</a>. Branch instructions can instead be expressed
via <code>if</code> statements.
</p>

<p>
Note that a <code>switch</code> statement with a sparse set
of <code>case</code> values can result in a large jump
table. Programmers and code generators are therefore expected to be
responsible for breaking up sparse value sets into
multiple <code>switch</code> statements separated
by <code>if</code>-guards if they wish to reduce the size of jump
tables.
</p>
</div>
-->

<!--
<h3>Statement Lists</h3>

<p>Just like statements, statement lists are validated in the context
of a <span>global environment</span> &Delta;, a <span>variable
environment</span> &Gamma;, and an expected return type &tau;. Unless
otherwise explicitly stated, a recursive validation of a subterm uses
the same context as its containing term.

<p>A <em>StatementList</em>

<div class="example">
<em>StatementList</em> : <em>StatementList<sub>opt</sub></em> <em>Statement</em>
</div>

<p>is valid if the <em>StatementList</em> (if any) is valid and the <em>Statement</em> is valid.
-->


<h3><em>ValidateCase</em>(&Delta;, &Gamma;, &tau;, <em>c</em>)</h3>

<p>Cases in a <code>switch</code> block are validated in the context
of a <span>global environment</span> &Delta;, a <span>variable
environment</span> &Gamma;, and an expected return type &tau;. Unless
otherwise explicitly stated, a recursive validation of a subterm uses
the same context as its containing term.

<!--
<h4>CaseBlock</h4>

<p>A <em>CaseBlock</em> node

<div class="example">
<code>{</code> <em>CaseClause</em>&hellip; <em>DefaultClause<sub>opt</sub></em> <code>}</code>
</div>

<p>is valid if the <em>CaseClause</em> list is valid and the <em>DefaultClause</em> (if any) is valid.
-->

<!--
<h4>CaseClauses</h4>

<p>A <em>CaseClauses</em> list

<div class="example">
<em>CaseClauses</em> : <em>CaseClauses<sub>opt</sub></em> <em>CaseClause</em>
</div>

<p>is valid if the <em>CaseClauses</em> (if any) are valid and the <em>CaseClause</em> is valid.
-->

<!--
<h4>CaseClause</h4>
-->

<p>Validating a <em>CaseClause</em> node

<div class="example">
<code>case</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em> <code>:</code> <em>stmt:Statement</em>&hellip;
</div>

<p>succeeds if

<ul>
<li>the source of <em>n</em> does not contain a <code>.</code> character;
<li><em>n</em> is in the range [-2<sup>31</sup>, 2<sup>31</sup>); and
<li><a href="#validatestatement-s"><em>ValidateStatement</em></a> succeeds for each <em>stmt</em>.
</ul>

<h3><em>ValidateDefault</em>(&Delta;, &Gamma;, &tau;, <em>d</em>)</h3>

<p>The default case in a <code>switch</code> block is validated in the
context of a <span>global environment</span> &Delta;, a <span>variable
environment</span> &Gamma;, and an expected return type &tau;. Unless
otherwise explicitly stated, a recursive validation of a subterm uses
the same context as its containing term.

<!--
<h4>DefaultClause</h4>
-->

<p>Validating a <em>DefaultClause</em> node

<div class="example">
<code>default :</code> <em>stmt:Statement</em>&hellip;
</div>

<p>succeeds
if <a href="#validatestatement-s"><em>ValidateStatement</em></a>
succeeds for each <em>stmt</em>.


<h3><em>ValidateExpression</em>(&Delta;, &Gamma;, <em>e</em>)</h3>

<p>Each expression is validated in the context of a <span>global
environment</span> &Delta; and a <span>variable environment</span>
&Gamma;, and validation produces the type of the expression as a
result. Unless otherwise explicitly stated, a recursive validation of
a subterm uses the same context as its containing term.

<h4>Expression</h4>

<p>Validating an <em>Expression</em> node

<div class="example">
<em>expr<sub>1</sub>:AssignmentExpression</em> <code>,</code> &hellip; <code>,</code> <em>expr<sub>n</sub>:AssignmentExpression</em>
</div>

<p>succeeds with type &tau; if for every <em>i</em>
&lt; <em>n</em>, one of the following conditions holds:

<ul>
<li><em>expr<sub>i</sub></em> is a <em>CallExpression</em>
and <a href="#validatecall-e"><em>ValidateCall</em></a> succeeds
with actual return type <code>void</code>; or
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr<sub>i</sub></em> with some type &sigma;;
</ul>

<p>and <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr<sub>n</sub></em> with type &tau;.

<h4>NumericLiteral</h4>

<p>Validating a <em>NumericLiteral</em> node

<ul>
<li>succeeds with type <code>double</code> if the source contains a <code>.</code> character; or
validates as type <code>double</code>;
<li>succeeds with type <code>fixnum</code> if the source does not contain a <code>.</code> character and its numeric value is in the range [0, 2<sup>31</sup>); or
<li>succeeds with type <code>unsigned</code> if the source does not contain a <code>.</code> character and its numeric value is in the range [2<sup>31</sup>, 2<sup>32</sup>).
</ul>

<p>Note that the case of negative integer constants is handled
under <a href="#unaryexpression"><em>UnaryExpression</em></a>.

<p>Note that integer literals outside the range [0, 2<sup>32</sup>)
are invalid, i.e., fail to validate.

<h4>Identifier</h4>

<p>Validating an <em>Identifier</em> node

<div class="example">
<em>x:Identifier</em>
</div>

<p>succeeds with type &tau; if <em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>) = &tau;.

<h4>CallExpression</h4>

<p>Validating a <em>CallExpression</em> node succeeds with
type <code>float</code>
if <a href="#validatefloatcoercion-e"><em>ValidateFloatCoercion</em></a>
succeeds.

<h4>MemberExpression</h4>

<p>Validating a <em>MemberExpression</em> node succeeds with type
&tau;
if <a href="#validateheapaccess-e"><em>ValidateHeapAccess</em></a>
succeeds with load type &tau;.

<h4>AssignmentExpression</h4>

<p>Validating an <em>AssignmentExpression</em> node

<div class="example">
<em>x:Identifier</em> <code>=</code> <em>expr:AssignmentExpression</em>
</div>

<p>succeeds with type &tau;
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for the nested <em>AssignmentExpression</em> with type &tau;
and one of the following two conditions holds:

<ul>
<li><em>x</em> is bound in &Gamma; as a supertype of &tau;; or
<li><em>x</em> is not bound in &Gamma; and is bound to a mutable supertype of &tau; in &Delta;.
</ul>

<p>Validating an <em>AssignmentExpression</em> node

<div class="example">
<em>lhs:MemberExpression</em> <code>=</code> <em>rhs:AssignmentExpression</em>
</div>

<p>succeeds with type &tau;
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>rhs</em> with type &tau;
and <a href="#validateheapaccess-e"><em>ValidateHeapAccess</em></a>
succeeds for <em>lhs</em> with &tau; as one of its legal store types.

<!--
<div class="example">
<em>x:Identifier</em><code>[</code><em>n:NumericLiteral</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
<em>x:Identifier</em><code>[</code><em>expr:Expression</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
<em>x:Identifier</em><code>[</code><em>expr:Expression</em> <code>&gt;&gt;</code> <em>n:NumericLiteral</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
</div>
-->

<h4>UnaryExpression</h4>

<p>Validating a <em>UnaryExpression</em> node of the form

<div class="example">
<code>-</code><em>NumericLiteral</em>
</div>

<p>succeeds with type <code>signed</code> if
the <em>NumericLiteral</em> source does not contain a <code>.</code>
character and the numeric value of the expression is in the range
[-2<sup>31</sup>, 0).

<p>Validating a <em>UnaryExpression</em> node of the form

<div class="example">
<code>+</code><em>cexpr:CallExpression</em>
</div>

<p>succeeds with type <code>double</code>
if <a href="#validatecall-e"><em>ValidateCall</em></a> succeeds
for <em>cexpr</em> with actual return type <code>double</code>.

<p>Validating a <em>UnaryExpression</em> node of the form

<div class="example">
<em>op:</em><span class="meta">(</span><code>+</code><span class="meta">|</span><code>-</code><span class="meta">|</span><code>~</code><span class="meta">|</span><code>!</code><span class="meta">)</span><em>arg:UnaryExpression</em>
</div>

<p>succeeds with type &tau; if the type of <em>op</em> is &hellip;
&and; (&sigma;) &rarr; &tau; &and; &hellip;
and <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds with a subtype of &sigma;.

<p>Validating a <em>UnaryExpression</em> node of the form

<div class="example">
<code>~~</code><em>arg:UnaryExpression</em>
</div>

<p>succeeds with type <code>signed</code>
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>arg</em> with a subtype of either <code>double</code>
or <code>float?</code>.

<h4>MultiplicativeExpression</h4>

<p>Validating a <em>MultiplicativeExpression</em> node

<div class="example">
<em>lhs:MultiplicativeExpression</em> <em>op:</em><span class="meta">(</span><code>*</code><span class="meta">|</span><code>/</code><span class="meta">|</span><code>%</code><span class="meta">)</span> <em>rhs:UnaryExpression</em>
</div>

<p>succeeds with type &tau; if:

<ul>
<li>the <a href="#binary-operators">binary operator type</a>
of <em>op</em> is &hellip; &and; (&sigma;<sub>1</sub>,
&sigma;<sub>2</sub>) &rarr; &tau; &and; &hellip;;
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>lhs</em> with a subtype of &sigma;<sub>1</sub>; and
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>rhs</em> with a subtype of &sigma;<sub>2</sub>.
</ul>

<p>Validating a <em>MultiplicativeExpression</em> node

<div class="example">
<em>expr:MultiplicativeExpression</em> <code>*</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><br>
<em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em> <code>*</code> <em>expr:UnaryExpression</em>
</div>

<p>succeeds with type <code>intish</code> if the source of <em>n</em>
does not contain a <code>.</code> character and -2<sup>20</sup>
&lt; <em>n</em> &lt; 2<sup>20</sup>
and <a href="#validateexpression-e"><em>ValidateExpression</em></a succeeds
for <em>expr</em> with a subtype of <code>int</code>.

<h4>AdditiveExpression</h4>

<p>Validating an <em>AdditiveExpression</em> node

<div class="example">
<em>expr<sub>1</sub></em> <span class="meta">(</span><code>+</code><span class="meta">|</span><code>-</code><span class="meta">)</span> &hellip; <span class="meta">(</span><code>+</code><span class="meta">|</span><code>-</code><span class="meta">)</span> <em>expr<sub>n</sub></em>
</div>

<p>succeeds with type <code>intish</code> if:

<ul>
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a> succeeds for each <em>expr<sub>i</sub></em> with a subtype of <code>int</code>;
<li><em>n</em> &leq; 2<sup>20</sup>.
</ul>

<p>Otherwise, validating an <em>AdditiveExpression</em> node

<div class="example">
<em>lhs:AdditiveExpression</em> <em>op:</em><span class="meta">(</span><code>+</code><span class="meta">|</span><code>-</code><span class="meta">)</span> <em>rhs:MultiplicativeExpression</em>
</div>

<p>succeeds with type <code>double</code> if:

<ul>
<li>the <a href="#binary-operators">binary operator type</a>
of <em>op</em> is (&sigma;<sub>1</sub>, &sigma;<sub>2</sub>)
&rarr; <code>double</code>;
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>lhs</em> with a subtype of &sigma;<sub>1</sub>; and
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>rhs</em> with a subtype of &sigma;<sub>2</sub>.
</ul>

<h4>ShiftExpression</h4>

<p>Validating a <em>ShiftExpression</em> node

<div class="example">
<em>lhs:ShiftExpression</em> <em>op:</em><span class="meta">(</span><code>&lt;&lt;</code><span class="meta">|</span><code>&gt;&gt;</code><span class="meta">|</span><code>&gt;&gt;&gt;</code><span class="meta">)</span> <em>rhs:AdditiveExpression</em>
<!--
<em>lhs:ShiftExpression</em> <code>&lt;&lt;</code> <em>rhs:AdditiveExpression</em><br>
<em>lhs:ShiftExpression</em> <code>&gt;&gt;</code> <em>rhs:AdditiveExpression</em><br>
<em>lhs:ShiftExpression</em> <code>&gt;&gt;&gt;</code> <em>rhs:AdditiveExpression</em><br>
-->
</div>

<p>succeeds with type &tau; if

<ul>
<li>the <a href="#binary-operators">binary operator type</a>
of <em>op</em> is &hellip; &and; (&sigma;<sub>1</sub>,
&sigma;<sub>2</sub>) &rarr; &tau; &and; &hellip;;
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>lhs</em> with a subtype of &sigma;<sub>1</sub>; and
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>rhs</em> with a subtype of &sigma;<sub>2</sub>.
</ul>

<h4>RelationalExpression</h4>

<p>Validating a <em>RelationalExpression</em> node

<div class="example">
<em>lhs:RelationalExpression</em> <em>op:</em><span class="meta">(</span><code>&lt;</code><span class="meta">|</span><code>&gt;</code><span class="meta">|</span><code>&lt;=</code><span class="meta">|</span><code>&gt;=</code><span class="meta">)</span> <em>rhs:ShiftExpression</em>
<!--
<em>lhs:RelationalExpression</em> <code>&lt;</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&gt;</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&lt;=</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&gt;=</code> <em>rhs:ShiftExpression</em><br>
-->
</div>

<p>succeeds with type &tau; if

<ul>
<li>the <a href="#binary-operators">binary operator type</a>
of <em>op</em> is &hellip; &and; (&sigma;<sub>1</sub>,
&sigma;<sub>2</sub>) &rarr; &tau; &and; &hellip;;
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>lhs</em> with a subtype of &sigma;<sub>1</sub>; and
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>rhs</em> with a subtype of &sigma;<sub>2</sub>.
</ul>

<h4>EqualityExpression</h4>

<p>Validating an <em>EqualityExpression</em> node

<div class="example">
<em>lhs:EqualityExpression</em> <em>op:</em><span class="meta">(</span><code>==</code><span class="meta">|</span><code>!=</code><span class="meta">)</span> <em>rhs:RelationalExpression</em>
<!--
<em>lhs:EqualityExpression</em> <code>==</code> <em>rhs:RelationalExpression</em><br>
<em>lhs:EqualityExpression</em> <code>!=</code> <em>rhs:RelationalExpression</em>
-->
</div>

<p>succeeds with type &tau; if

<ul>
<li>the <a href="#binary-operators">binary operator type</a>
of <em>op</em> is &hellip; &and; (&sigma;<sub>1</sub>,
&sigma;<sub>2</sub>) &rarr; &tau; &and; &hellip;;
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>lhs</em> with a subtype of &sigma;<sub>1</sub>; and
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>rhs</em> with a subtype of &sigma;<sub>2</sub>.
</ul>

<h4>BitwiseANDExpression</h4>

<p>Validating a <em>BitwiseANDExpression</em> node

<div class="example">
<em>lhs:BitwiseANDExpression</em> <code>&amp;</code> <em>rhs:EqualityExpression</em><br>
</div>

<p>succeeds with type <code>signed</code>
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>lhs</em> and <em>rhs</em> with
a subtype of <code>intish</code>.

<h4>BitwiseXORExpression</h4>

<p>Validating a <em>BitwiseXORExpression</em> node

<div class="example">
<em>lhs:BitwiseXORExpression</em> <code>^</code> <em>rhs:BitwiseANDExpression</em><br>
</div>

<p>succeeds with type <code>signed</code>
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>lhs</em> and <em>rhs</em> with
a subtype of <code>intish</code>.

<h4>BitwiseORExpression</h4>

<p>Validating a <em>BitwiseORExpression</em> node

<div class="example">
<em>cexpr:CallExpression</em> <code>|0</code><br>
</div>

<p>succeeds with type <code>signed</code>
if <a href="#validatecall-e"><em>ValidateCall</em></a> succeeds
for <em>cexpr</em> with actual return type <code>signed</code>.

<p>Validating a <em>BitwiseORExpression</em> node

<div class="example">
<em>lhs:BitwiseORExpression</em> <code>|</code> <em>rhs:BitwiseXORExpression</em><br>
</div>

<p>succeeds with type <code>signed</code>
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>lhs</em> and <em>rhs</em> with
a subtype of <code>intish</code>.

<h4>ConditionalExpression</h4>

<p>Validating a <em>ConditionalExpression</em> node

<div class="example">
<em>test:BitwiseORExpression</em> <code>?</code> <em>cons:AssignmentExpression</em> <code>:</code> <em>alt:AssignmentExpression</em>
</div>

<p>succeeds with type &tau; if:

<ul>
<li>&tau; is one of <code>int</code>, <code>double</code>, or <code>float</code>;
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a> succeeds for <em>test</em> with a subtype of <code>int</code>;
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a> succeeds for <em>cons</em> and <em>alt</em> with subtypes of &tau;.
</ul>

<h4>Parenthesized Expression</h4>

<p>Validating a parenthesized expression node

<div class="example">
<code>(</code> <em>expr:Expression</em> <code>)</code>
</div>

<p>succeeds with type &tau;
if <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>expr</em> with type &tau;.


<h3><em>ValidateCall</em>(&Delta;, &Gamma;, &tau;, <em>e</em>)</h3>

<p>Each function call expression is validated in the context of a
global environment &Delta; and a variable environment &Gamma;, and
validates against an <em>actual return type</em> &tau;, which was
provided from the context in which the function call appears. A
recursive validation of a subterm uses the same context as its
containing term.

<p>Validating a <em>CallExpression</em> node

<div class="example">
<em>f:Identifier</em><code>(</code><em>arg:Expression</em><code>,</code>&hellip;<code>)</code>
</div>

<p>with actual return type &tau; succeeds if one of the following
conditions holds:

<ul>
<li><a href="#validatefloatcoercion-e"><em>ValidateFloatCoercion</em></a>
succeeds for the node;
<li><em>Lookup</em>(&Delta;, &Gamma;, <em>f</em>) = &hellip; &and;
(&sigma;,&hellip;) &rarr; &tau; &and; &hellip;
and <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for each <em>arg</em> with a subtype of its corresponding
&sigma;; or
<li><em>Lookup</em>(&Delta;, &Gamma;, <em>f</em>) = &hellip; &and;
(&sigma;<sub>1</sub>,&hellip;,&sigma;<sub><em>n</em></sub>,&sigma;<code>&hellip;</code>)
&rarr; &tau; &and; &hellip;
and <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for the first <em>n</em> <em>arg<sub>i</sub></em> expressions
with subtypes of their corresponding &sigma;<sub><em>i</em></sub> and
the remaining <em>arg</em> expressions with subtypes of &sigma;.
</ul>

<p>Alternatively, validating the <em>CallExpression</em> succeeds with
any actual return type &tau; other than <code>float</code>
if <em>Lookup</em>(&Delta;, &Gamma;, <em>f</em>)
= <code>Function</code>
and <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for each <em>arg</em> with a subtype of <code>extern</code>.

<!--
<div class="compilation">
<p>
Calls to local functions can be compiled to efficient code that enters
the well-typed body of functions, skipping past the dynamic type
coercions.
</p>

<p>
Calls to <code>stdlib</code> functions can be similarly compiled to
skip the dynamic type coercions of ECMAScript standard library
functions.
</p>

<p>
Calls to <code>foreign</code> functions, by contrast, require boxing
the internal representation of values as standard dynamic values in
whatever representation required by the JavaScript engine.
</p>
</div>
-->

<p>Validating a <em>CallExpression</em> node

<div class="example">
<em>x:Identifier</em><code>[</code><em>index:Expression</em><code> &amp; </code><em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>](</code><em>arg:Expression</em><code>,</code>&hellip;<code>)</code>
</div>

<p>succeeds with actual return type &tau; if:

<ul>
<li>the source of <em>n</em> does not contain a <code>.</code> character;
<li><em>Lookup</em>(&Delta;,
&Gamma;, <em>x</em>) = ((&sigma;,&hellip;) &rarr;
&tau;)[<em>n+1</em>];
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>index</em> with a subtype of <code>intish</code>; and
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for each <em>arg</em> with a subtype of its corresponding
&sigma;.
</ul>

<!--
<div class="compilation">
<p>
Calls to function pointers 
</p>
</div>
-->

<h3><em>ValidateHeapAccess</em>(&Delta;, &Gamma;, <em>e</em>)</h3>

<p>Each heap access expression is validated in the context of a global
environment &Delta; and a variable environment &Gamma;, and validation
produces a <em>load type</em> as well as a set of legal <em>store
types</em> as a result. These types are determined by
the <a href="#heap-view-types">heap view types</a> corresponding to
each <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type.

<p>Validating a <em>MemberExpression</em> node

<div class="example">
<em>x:Identifier</em><code>[</code><em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>]</code>
</div>

<p>succeeds with load type &sigma; and store types { &tau;, &hellip; } if:

<ul>
<li><em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>) = <em>view</em>
where <em>view</em> is
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type;
<li>the load type of <em>view</em> is &sigma;;
<li>the store types of <em>view</em> are { &tau;, &hellip; };
<li>the source of <em>n</em> does not contain a <code>.</code> character;
<li>0 &leq; <em>n</em> &lt; 2<sup>32</sup>.
</ul>

<p>Validating a <em>MemberExpression</em> node

<div class="example">
<em>x:Identifier</em><code>[</code><em>expr:Expression</em> <code>&gt;&gt;</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>]</code>
</div>

<p>succeeds with load type &sigma; and store types { &tau;, &hellip; }
if:

<ul>
<li><em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>) = <em>view</em> where <em>view</em> is
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type;
<li>the element size of <em>view</em> is <em>bytes</em>;
<li>the load type of <em>view</em> is &sigma;;
<li>the store types of <em>view</em> are { &tau;, &hellip; };
<li><a href="#validateexpression-e"><em>ValidateExpression</em></a> succeeds for <em>expr</em> with type <code>intish</code>;
<li>the source of <em>n</em> does not contain a <code>.</code> character;
<li><em>n</em> = log<sub>2</sub>(<em>bytes</em>).
</ul>

<!--
<div class="compilation">
<p><em>TODO: explain compilation model of heap access</em></p>
</div>
-->

<h3><em>ValidateFloatCoercion</em>(&Delta;, &Gamma;, <em>e</em>)</h3>

<p>A call to the <code>fround</code> coercion is validated in the
context of a global environment &Delta; and a variable environment
&Gamma; and validates as the type <code>float</code>.

<p>Validating a <em>CallExpression</em> node

<div class="example">
<em>f:Identifier</em><code>(</code><em>cexpr:CallExpression</em><code>)</code>
</div>

<p>succeeds with type <code>float</code> if <em>Lookup</em>(&Delta;,
&Gamma;, <em>f</em>) = <code>fround</code> and <a href="#validatecall-e"><em>ValidateCall</em></a> succeeds for
<em>cexpr</em> with actual return type <code>float</code>.

<p>Alternatively, validating a <em>CallExpression</em> node

<div class="example">
<em>f:Identifier</em><code>(</code><em>arg:Expression</em><code>)</code>
</div>

<p>succeeds with type <code>float</code> if <em>Lookup</em>(&Delta;,
&Gamma;, <em>f</em>) = <code>fround</code>
and <a href="#validateexpression-e"><em>ValidateExpression</em></a>
succeeds for <em>arg</em> with type &tau;, where &tau; is a subtype
of <code>floatish</code>, <code>double?</code>, <code>signed</code>,
or <code>unsigned</code>.


<h2>Linking</h2>

<p>An AOT implementation of asm.js must perform some internal dynamic
checks at link time to be able to safely generate AOT-compiled
exports. If any of the dynamic checks fails, the result of linking
cannot be an AOT-compiled module. The dynamically checked invariants
are:

<ul>
<li>control must reach the module's <code>return</code> statement without throwing;
<li>all property access must resolve to data properties;
<li>the <em>heap</em> object (if provided) must be an instance of <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a>;
<li>the <em>heap</em> object's <code>byteLength</code> must be either 2<sup><em>n</em></sup> for <em>n</em> in [12, 24) or 2<sup>24</sup> &middot; <em>n</em> for <em>n</em> &geq; 1;
<!--
<li>the <em>heap</em> object's <code>byteLength</code> must be a multiple of 4096;
<li>the <em>heap</em> object's <code>byteLength</code> must be a power of 2;
<li>the <em>heap</em> object's <code>byteLength</code> must be no greater than 2<sup>31</sup> (assuming the engine even allows <code>ArrayBuffer</code>s that large);
-->
<li>all globals taken from the <em>stdlib</em> object must be
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-9.12">SameValue</a>
as the
corresponding <a href="http://ecma-international.org/ecma-262/5.1/#sec-15">standard
library</a> of the same name.
</ul>

<p>If any of these conditions is not met, AOT compilation may produce
invalid results so the engine should fall back to an interpreted or
JIT-compiled implementation.

<h2>Operators</h2>

<h3>Unary Operators</h3>

<table>
<tbody>
<tr>
  <th>Unary Operator</th>
  <th>Type</th>
</tr>
<tr>
  <td><code>+</code></td>
  <td>
    (<code>signed</code>) &rarr; <code>double</code> &and;<br>
    (<code>unsigned</code>) &rarr; <code>double</code> &and;<br>
    (<code>double?</code>) &rarr; <code>double</code> &and;<br>
    (<code>float?</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>-</code></td>
  <td>
    (<code>int</code>) &rarr; <code>intish</code> &and;<br>
    (<code>double?</code>) &rarr; <code>double</code> &and;<br>
    (<code>float?</code>) &rarr; <code>floatish</code>
  </td>
</tr>
<tr>
  <td><code>~</code></td>
  <td>(<code>intish</code>) &rarr; <code>signed</code></td>
</tr>
<tr>
  <td><code>!</code></td>
  <td>(<code>int</code>) &rarr; <code>int</code></td>
</tr>
</tbody>
</table>

<p>Note that the special combined operator <code>~~</code> may be used
as a coercion from <code>double</code> or <code>float?</code>
to <code>signed</code>; see <a href="#unaryexpression">Unary
Expressions</a>.

<h3>Binary Operators</h3>

<table>
<tbody>
<tr>
  <th>Binary Operator</th>
  <th>Type</th>
</tr>
<tr>
  <td><code>+</code></td>
  <td>
    (<code>double</code>, <code>double</code>) &rarr; <code>double</code> &and;<br>
    (<code>float?</code>, <code>float?</code>) &rarr; <code>floatish</code>
  </td>
</tr>
<tr>
  <td><code>-</code></td>
  <td>
    (<code>double?</code>, <code>double?</code>) &rarr; <code>double</code> &and;<br>
    (<code>float?</code>, <code>float?</code>) &rarr; <code>floatish</code>
  </td>
</tr>
<tr>
  <td><code>*</code></td>
  <td>
    (<code>double?</code>, <code>double?</code>) &rarr; <code>double</code> &and;<br>
    (<code>float?</code>, <code>float?</code>) &rarr; <code>floatish</code>
  </td>
</tr>
<tr>
  <td><code>/</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>intish</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>intish</code> &and;<br>
    (<code>double?</code>, <code>double?</code>) &rarr; <code>double</code> &and;<br>
    (<code>float?</code>, <code>float?</code>) &rarr; <code>floatish</code>
  </td>
</tr>
<tr>
  <td><code>%</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>intish</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>intish</code> &and;<br>
    (<code>double?</code>, <code>double?</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>|</code>, <code>&amp;</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
  <td>(<code>intish</code>, <code>intish</code>) &rarr; <code>signed</code></td>
</tr>
<tr>
  <td><code>&gt;&gt;&gt;</code></td>
  <td>(<code>intish</code>, <code>intish</code>) &rarr; <code>unsigned</code></td>
</tr>
<tr>
  <td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>int</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>int</code> &and;<br>
    (<code>double</code>, <code>double</code>) &rarr; <code>int</code> &and;<br>
    (<code>float</code>, <code>float</code>) &rarr; <code>int</code>
  </td>
</tr>
</tbody>
</table>

<h2>Standard Library</h2>

<table>
<tbody>
<tr>
  <th>Standard Library</th>
  <th>Type</th>
</tr>
<tr>
  <td>
    <code>Infinity</code><br>
    <code>NaN</code>
  </td>
  <td><code>double</code></td>
</tr>
<tr>
  <td>
    <code>Math.acos</code><br>
    <code>Math.asin</code><br>
    <code>Math.atan</code><br>
    <code>Math.cos</code><br>
    <code>Math.sin</code><br>
    <code>Math.tan</code><br>
    <code>Math.exp</code><br>
    <code>Math.log</code>
  </td>
  <td>(<code>double?</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td>
    <code>Math.ceil</code><br>
    <code>Math.floor</code><br>
    <code>Math.sqrt</code>
  </td>
  <td>
    (<code>double?</code>) &rarr; <code>double</code> &and;<br>
    (<code>float?</code>) &rarr; <code>float</code>
  </td>
</tr>
<tr>
  <td><code>Math.abs</code></td>
  <td>
    (<code>signed</code>) &rarr; <code>signed</code> &and;<br>
    (<code>double?</code>) &rarr; <code>double</code> &and;<br>
    (<code>float?</code>) &rarr; <code>float</code>
  </td>
</tr>
<tr>
  <td>
    <code>Math.min</code><br>
    <code>Math.max</code>
  </td>
  <td>
    (<code>int</code>, <code>int</code><code>&hellip;</code>) &rarr; <code>signed</code> &and;<br>
    (<code>double</code>, <code>double</code><code>&hellip;</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td>
    <code>Math.atan2</code><br>
    <code>Math.pow</code>
  </td>
  <td>(<code>double?</code>, <code>double?</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>Math.imul</code></td>
  <td>(<code>int</code>, <code>int</code>) &rarr; <code>signed</code></td>
</tr>
<tr>
  <td><code>Math.fround</code></td>
  <td><code>fround</code></td>
</tr>
<tr>
  <td>
    <code>Math.E</code><br>
    <code>Math.LN10</code><br>
    <code>Math.LN2</code><br>
    <code>Math.LOG2E</code><br>
    <code>Math.LOG10E</code><br>
    <code>Math.PI</code><br>
    <code>Math.SQRT1_2</code><br>
    <code>Math.SQRT2</code><br>
  </td>
  <td><code>double</code></td>
</tr>
</tbody>
</table>

<h2>Heap View Types</h2>

<table>
<tbody>
<tr>
  <th>View Type</th>
  <th>Element Size (Bytes)</th>
  <th>Load Type</th>
  <th>Store Types</th>
</tr>
<tr>
  <td><code>Uint8Array</code></td>
  <td>1</td>
  <td><code>intish</code></td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Int8Array</code></td>
  <td>1</td>
  <td><code>intish</code></td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Uint16Array</code></td>
  <td>2</td>
  <td><code>intish</code></td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Int16Array</code></td>
  <td>2</td>
  <td><code>intish</code></td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Uint32Array</code></td>
  <td>4</td>
  <td><code>intish</code></td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Int32Array</code></td>
  <td>4</td>
  <td><code>intish</code></td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Float32Array</code></td>
  <td>4</td>
  <td><code>float?</code></td>
  <td><code>floatish</code>, <code>double?</code></td>
</tr>
<tr>
  <td><code>Float64Array</code></td>
  <td>8</td>
  <td><code>double?</code></td>
  <td><code>float?</code>, <code>double?</code></td>
</tr>
</tbody>
</table>

<h2 class="no-num">Acknowledgements</h2>

<p>Thanks to Martin Best, Brendan Eich, Andrew McCreight, and Vlad
Vuki&cacute;evi&cacute; for feedback and encouragement.</p>

<p>Thanks to Benjamin Bouvier, Douglas Crosher, and Dan Gohman for
contributions to the design and implementation, particularly for
<code>float</code>.</p>

<p>Thanks to Jesse Ruderman and C. Scott Ananian for bug reports.</p>

<p>Thanks to Michael Bebenita for diagrams.</p>

</body>
</html>
